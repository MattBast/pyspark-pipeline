{
    "constraint_suggestions": [
        {
            "constraint_name": "CompletenessConstraint(Completeness(PassengerId,None))",
            "column_name": "PassengerId",
            "current_value": "Completeness: 1.0",
            "description": "'PassengerId' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"PassengerId\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('PassengerId' has no negative values,PassengerId >= 0,None))",
            "column_name": "PassengerId",
            "current_value": "Minimum: 1.0",
            "description": "'PassengerId' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"PassengerId\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(PassengerId,None),<function1>,Some(<function1>),None)",
            "column_name": "PassengerId",
            "current_value": "DataType: Integral",
            "description": "'PassengerId' has type Integral",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"PassengerId\", ConstrainableDataTypes.Integral)"
        },
        {
            "constraint_name": "UniquenessConstraint(Uniqueness(List(PassengerId),None))",
            "column_name": "PassengerId",
            "current_value": "ApproxDistinctness: 0.9966329966329966",
            "description": "'PassengerId' is unique",
            "suggesting_rule": "UniqueIfApproximatelyUniqueRule()",
            "rule_description": "If the ratio of approximate num distinct values in a column is close to the number of records (within the error of the HLL sketch), we suggest a UNIQUE constraint",
            "code_for_constraint": ".isUnique(\"PassengerId\")"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Name,None))",
            "column_name": "Name",
            "current_value": "Completeness: 1.0",
            "description": "'Name' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Name\")"
        },
        {
            "constraint_name": "UniquenessConstraint(Uniqueness(List(Name),None))",
            "column_name": "Name",
            "current_value": "ApproxDistinctness: 1.0505050505050506",
            "description": "'Name' is unique",
            "suggesting_rule": "UniqueIfApproximatelyUniqueRule()",
            "rule_description": "If the ratio of approximate num distinct values in a column is close to the number of records (within the error of the HLL sketch), we suggest a UNIQUE constraint",
            "code_for_constraint": ".isUnique(\"Name\")"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Ticket,None))",
            "column_name": "Ticket",
            "current_value": "Completeness: 1.0",
            "description": "'Ticket' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Ticket\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Pclass' has value range '3', '1', '2',`Pclass` IN ('3', '1', '2'),None))",
            "column_name": "Pclass",
            "current_value": "Compliance: 1",
            "description": "'Pclass' has value range '3', '1', '2'",
            "suggesting_rule": "CategoricalRangeRule(com.amazon.deequ.suggestions.rules.CategoricalRangeRule$$$Lambda$3798/0x000000080167f040@4645e406)",
            "rule_description": "If we see a categorical range for a column, we suggest an IS IN (...) constraint",
            "code_for_constraint": ".isContainedIn(\"Pclass\", [\"3\", \"1\", \"2\"])"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Pclass,None))",
            "column_name": "Pclass",
            "current_value": "Completeness: 1.0",
            "description": "'Pclass' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Pclass\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Pclass' has no negative values,Pclass >= 0,None))",
            "column_name": "Pclass",
            "current_value": "Minimum: 1.0",
            "description": "'Pclass' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"Pclass\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(Pclass,None),<function1>,Some(<function1>),None)",
            "column_name": "Pclass",
            "current_value": "DataType: Integral",
            "description": "'Pclass' has type Integral",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"Pclass\", ConstrainableDataTypes.Integral)"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Parch,None))",
            "column_name": "Parch",
            "current_value": "Completeness: 1.0",
            "description": "'Parch' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Parch\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Parch' has value range '0', '1', '2' for at least 97.0% of values,`Parch` IN ('0', '1', '2'),None))",
            "column_name": "Parch",
            "current_value": "Compliance: 0.9831649831649831",
            "description": "'Parch' has value range '0', '1', '2' for at least 97.0% of values",
            "suggesting_rule": "FractionalCategoricalRangeRule(0.9,com.amazon.deequ.suggestions.rules.FractionalCategoricalRangeRule$$$Lambda$3799/0x000000080167e840@2d6760d7)",
            "rule_description": "If we see a categorical range for most values in a column, we suggest an IS IN (...) constraint that should hold for most values",
            "code_for_constraint": ".isContainedIn(\"Parch\", [\"0\", \"1\", \"2\"], lambda x: x >= 0.97, \"It should be above 0.97!\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Parch' has no negative values,Parch >= 0,None))",
            "column_name": "Parch",
            "current_value": "Minimum: 0.0",
            "description": "'Parch' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"Parch\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(Parch,None),<function1>,Some(<function1>),None)",
            "column_name": "Parch",
            "current_value": "DataType: Integral",
            "description": "'Parch' has type Integral",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"Parch\", ConstrainableDataTypes.Integral)"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Embarked' has value range 'S', 'C', 'Q',`Embarked` IN ('S', 'C', 'Q'),None))",
            "column_name": "Embarked",
            "current_value": "Compliance: 1",
            "description": "'Embarked' has value range 'S', 'C', 'Q'",
            "suggesting_rule": "CategoricalRangeRule(com.amazon.deequ.suggestions.rules.CategoricalRangeRule$$$Lambda$3798/0x000000080167f040@4645e406)",
            "rule_description": "If we see a categorical range for a column, we suggest an IS IN (...) constraint",
            "code_for_constraint": ".isContainedIn(\"Embarked\", [\"S\", \"C\", \"Q\"])"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Embarked' has value range 'S', 'C' for at least 89.0% of values,`Embarked` IN ('S', 'C'),None))",
            "column_name": "Embarked",
            "current_value": "Compliance: 0.9113355780022447",
            "description": "'Embarked' has value range 'S', 'C' for at least 89.0% of values",
            "suggesting_rule": "FractionalCategoricalRangeRule(0.9,com.amazon.deequ.suggestions.rules.FractionalCategoricalRangeRule$$$Lambda$3799/0x000000080167e840@2d6760d7)",
            "rule_description": "If we see a categorical range for most values in a column, we suggest an IS IN (...) constraint that should hold for most values",
            "code_for_constraint": ".isContainedIn(\"Embarked\", [\"S\", \"C\"], lambda x: x >= 0.89, \"It should be above 0.89!\")"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Embarked,None))",
            "column_name": "Embarked",
            "current_value": "Completeness: 0.9977553310886644",
            "description": "'Embarked' has less than 1% missing values",
            "suggesting_rule": "RetainCompletenessRule()",
            "rule_description": "If a column is incomplete in the sample, we model its completeness as a binomial variable, estimate a confidence interval and use this to define a lower bound for the completeness",
            "code_for_constraint": ".hasCompleteness(\"Embarked\", lambda x: x >= 0.99, \"It should be above 0.99!\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Age' has no negative values,Age >= 0,None))",
            "column_name": "Age",
            "current_value": "Minimum: 0.42",
            "description": "'Age' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"Age\")"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Age,None))",
            "column_name": "Age",
            "current_value": "Completeness: 0.8013468013468014",
            "description": "'Age' has less than 23% missing values",
            "suggesting_rule": "RetainCompletenessRule()",
            "rule_description": "If a column is incomplete in the sample, we model its completeness as a binomial variable, estimate a confidence interval and use this to define a lower bound for the completeness",
            "code_for_constraint": ".hasCompleteness(\"Age\", lambda x: x >= 0.77, \"It should be above 0.77!\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(Age,None),<function1>,Some(<function1>),None)",
            "column_name": "Age",
            "current_value": "DataType: Fractional",
            "description": "'Age' has type Fractional",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"Age\", ConstrainableDataTypes.Fractional)"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Cabin,None))",
            "column_name": "Cabin",
            "current_value": "Completeness: 0.22895622895622897",
            "description": "'Cabin' has less than 80% missing values",
            "suggesting_rule": "RetainCompletenessRule()",
            "rule_description": "If a column is incomplete in the sample, we model its completeness as a binomial variable, estimate a confidence interval and use this to define a lower bound for the completeness",
            "code_for_constraint": ".hasCompleteness(\"Cabin\", lambda x: x >= 0.2, \"It should be above 0.2!\")"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Fare,None))",
            "column_name": "Fare",
            "current_value": "Completeness: 1.0",
            "description": "'Fare' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Fare\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Fare' has no negative values,Fare >= 0,None))",
            "column_name": "Fare",
            "current_value": "Minimum: 0.0",
            "description": "'Fare' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"Fare\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(Fare,None),<function1>,Some(<function1>),None)",
            "column_name": "Fare",
            "current_value": "DataType: Fractional",
            "description": "'Fare' has type Fractional",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"Fare\", ConstrainableDataTypes.Fractional)"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('SibSp' has value range '0', '1', '2', '4', '3', '8', '5',`SibSp` IN ('0', '1', '2', '4', '3', '8', '5'),None))",
            "column_name": "SibSp",
            "current_value": "Compliance: 1",
            "description": "'SibSp' has value range '0', '1', '2', '4', '3', '8', '5'",
            "suggesting_rule": "CategoricalRangeRule(com.amazon.deequ.suggestions.rules.CategoricalRangeRule$$$Lambda$3798/0x000000080167f040@4645e406)",
            "rule_description": "If we see a categorical range for a column, we suggest an IS IN (...) constraint",
            "code_for_constraint": ".isContainedIn(\"SibSp\", [\"0\", \"1\", \"2\", \"4\", \"3\", \"8\", \"5\"])"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(SibSp,None))",
            "column_name": "SibSp",
            "current_value": "Completeness: 1.0",
            "description": "'SibSp' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"SibSp\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('SibSp' has value range '0', '1' for at least 89.0% of values,`SibSp` IN ('0', '1'),None))",
            "column_name": "SibSp",
            "current_value": "Compliance: 0.9169472502805835",
            "description": "'SibSp' has value range '0', '1' for at least 89.0% of values",
            "suggesting_rule": "FractionalCategoricalRangeRule(0.9,com.amazon.deequ.suggestions.rules.FractionalCategoricalRangeRule$$$Lambda$3799/0x000000080167e840@2d6760d7)",
            "rule_description": "If we see a categorical range for most values in a column, we suggest an IS IN (...) constraint that should hold for most values",
            "code_for_constraint": ".isContainedIn(\"SibSp\", [\"0\", \"1\"], lambda x: x >= 0.89, \"It should be above 0.89!\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('SibSp' has no negative values,SibSp >= 0,None))",
            "column_name": "SibSp",
            "current_value": "Minimum: 0.0",
            "description": "'SibSp' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"SibSp\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(SibSp,None),<function1>,Some(<function1>),None)",
            "column_name": "SibSp",
            "current_value": "DataType: Integral",
            "description": "'SibSp' has type Integral",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"SibSp\", ConstrainableDataTypes.Integral)"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Survived' has value range '0', '1',`Survived` IN ('0', '1'),None))",
            "column_name": "Survived",
            "current_value": "Compliance: 1",
            "description": "'Survived' has value range '0', '1'",
            "suggesting_rule": "CategoricalRangeRule(com.amazon.deequ.suggestions.rules.CategoricalRangeRule$$$Lambda$3798/0x000000080167f040@4645e406)",
            "rule_description": "If we see a categorical range for a column, we suggest an IS IN (...) constraint",
            "code_for_constraint": ".isContainedIn(\"Survived\", [\"0\", \"1\"])"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Survived,None))",
            "column_name": "Survived",
            "current_value": "Completeness: 1.0",
            "description": "'Survived' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Survived\")"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Survived' has no negative values,Survived >= 0,None))",
            "column_name": "Survived",
            "current_value": "Minimum: 0.0",
            "description": "'Survived' has no negative values",
            "suggesting_rule": "NonNegativeNumbersRule()",
            "rule_description": "If we see only non-negative numbers in a column, we suggest a corresponding constraint",
            "code_for_constraint": ".isNonNegative(\"Survived\")"
        },
        {
            "constraint_name": "AnalysisBasedConstraint(DataType(Survived,None),<function1>,Some(<function1>),None)",
            "column_name": "Survived",
            "current_value": "DataType: Integral",
            "description": "'Survived' has type Integral",
            "suggesting_rule": "RetainTypeRule()",
            "rule_description": "If we detect a non-string type, we suggest a type constraint",
            "code_for_constraint": ".hasDataType(\"Survived\", ConstrainableDataTypes.Integral)"
        },
        {
            "constraint_name": "ComplianceConstraint(Compliance('Sex' has value range 'male', 'female',`Sex` IN ('male', 'female'),None))",
            "column_name": "Sex",
            "current_value": "Compliance: 1",
            "description": "'Sex' has value range 'male', 'female'",
            "suggesting_rule": "CategoricalRangeRule(com.amazon.deequ.suggestions.rules.CategoricalRangeRule$$$Lambda$3798/0x000000080167f040@4645e406)",
            "rule_description": "If we see a categorical range for a column, we suggest an IS IN (...) constraint",
            "code_for_constraint": ".isContainedIn(\"Sex\", [\"male\", \"female\"])"
        },
        {
            "constraint_name": "CompletenessConstraint(Completeness(Sex,None))",
            "column_name": "Sex",
            "current_value": "Completeness: 1.0",
            "description": "'Sex' is not null",
            "suggesting_rule": "CompleteIfCompleteRule()",
            "rule_description": "If a column is complete in the sample, we suggest a NOT NULL constraint",
            "code_for_constraint": ".isComplete(\"Sex\")"
        }
    ]
}